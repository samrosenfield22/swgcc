;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; grammar for the c programming language, sort of							   ;;;;;
;;;;; by default, the token on the lhs of the first production is the start symbol ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;jump id 	meaning
;0 			function postamble
;1,2		misc conditionals
;3 			ret from function call

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; top-level productions

<stmtlist>		::= <stmt>
<stmtlist>		::= <block>
<block>			::= "{" {! alloc_lcls} <stmtlist>* {! free_lcls} {! declare_vars} "}"

<stmt>			::= <mstmt>
<stmt>			::= <if>
<stmt>			::= <while>
<stmt>			::= <dowhile>
<stmt>			::= <forloop>
<stmt>			::= "return" <comma> ";" {pop eax} {pushaddr 0} {jmp}

<mstmt>			::= <comma> ";" {! declare_vars} {pop}
<mstmt>			::= <decl>

;maybe lol
<decl>			::= type {! add_decl_var parent.2.0} <base_id> <declspec> {! handle_lvcontext parent.2}

<declspec>		::= <decl_assign> <mdecl_assign>* ";" {! declare_vars} {pop}
<declspec>		::= <mdecl_assign>* ";" {! declare_vars} {pop}
<declspec>		::= <funcdef> {! define_function parent.parent.2.0, parent.0.1}
<declspec>		::= ";" {! declare_vars} {pop}
<mdecl_assign>	::= "," {pop} {! add_decl_var parent.3.0} <base_id> <decl_assign>?  {! handle_lvcontext parent.3}

<decl_assign>	::= <var_assign>
<decl_assign>	::= <array_assign>

<var_assign>	::= "=" <assign> {=}

<array_assign>	::= "[" <array_def>
<array_def>		::= <base_num> "]" <array_init>?
<array_def>		::= "]" <array_init>
<array_init>	::= "=" "{" <array_vals> "}"
<array_vals>	::= <base> <array_more>*
<array_more>	::= "," <base>



<comma>       	::= <assign> <mcomma>*
<mcomma>      	::= "," {pop} <assign> {,}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; conditionals

<if>			::= "if" "(" <comma> ")" {pushaddr 1} {jz} <stmtlist> {jumplabel 1}

;the comma and stmtlist branches get swapped
<while>			::= "while" "(" {pushaddr 1} {jmp} {jumplabel 2} <comma> ")" {jumplabel 1} <stmtlist> {pushaddr 2} {jnz} {! swap_nodes parent.5, parent.8}

<dowhile>		::= "do" {jumplabel 1} <stmtlist> "while" "(" <comma> ")" {pushaddr 1} {jnz}

;the condition (first comma) and stmtlist get swapped
<forloop>		::= "for" "(" <mstmt>? {pushaddr 1} {jmp} {jumplabel 2} ";" <comma>? ";" <comma>? {jumplabel 1} ")" <stmtlist> {pushaddr 2} {jnz}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; functions

;if the function contains a return statement, this stores the return value in eax, then jumps to jumplabel 0,
;skipping the {push 0} {pop eax}
;if execution reaches the end of the block (without hitting a return statement), then we set eax=0
<funcdef>		::= "(" <funcdeflist> ")" {enter} <block> {push 0} {pop eax} {jumplabel 0} {leave} {ret}
<funcdeflist>	::= "void"
<funcdeflist>	::= <funcdefarg> <mfuncdefarg>*
;<funcdefarg>	::= type {! add_decl_var parent.2.0} <base_id>
<funcdefarg>	::= type {! add_decl_var parent.2} id
<mfuncdefarg>	::= "," <funcdefarg>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; expressions (arithmetic, logical, bitwise, assignment)

<assign>		::= <logical> <massign>?
<massign> 		::= "=" <assign> {=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "+=" <assign> {+=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "-=" <assign> {-=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "*=" <assign> {*=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "/=" <assign> {/=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "%=" <assign> {%=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "<<=" <assign> {<<=} {! handle_lvcontext parent.parent.0}
<massign> 		::= ">>=" <assign> {>>=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "&=" <assign> {&=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "|=" <assign> {|=} {! handle_lvcontext parent.parent.0}
<massign> 		::= "^=" <assign> {^=} {! handle_lvcontext parent.parent.0}


<logical>		::= <bitwise> <mlogical>*
<mlogical>    	::= "&&" <bitwise> {&&}
<mlogical>    	::= "||" <bitwise> {||}

<bitwise>     	::= <equality> <mbitwise>*
<mbitwise>    	::= "&" <equality> {&}
<mbitwise>    	::= "|" <equality> {|}
<mbitwise>    	::= "^" <equality> {^}

<equality>    	::= <relational> <mequality>*
<mequality>   	::= "==" <equality> {==}
<mequality>   	::= "!=" <equality> {!=}

<relational>  	::= <shift> <mrelational>*
<mrelational> 	::= ">" <shift> {>}
<mrelational> 	::= ">=" <shift> {>=}
<mrelational> 	::= "<" <shift> {<}
<mrelational> 	::= "<=" <shift> {<=}

<shift>       	::= <sum> <mshift>*
<mshift>      	::= "<<" <sum> {<<}
<mshift>      	::= ">>" <sum> {>>}

<sum>			::= <prod> <msum>*
<msum>			::= "+" <prod> {+}
<msum>			::= "-" <prod> {-}

<prod>        	::= <misc2> <mprod>*
<mprod>       	::= "*" <misc2> {*}
<mprod>       	::= "/" <misc2> {/}
<mprod>       	::= "%" <misc2> {%}

<misc2>			::= <misc1>
<misc2>			::= <misc2_lval>
<misc2>			::= <misc2_context>
<misc2>			::= "!" <misc2> {!}
<misc2>			::= "~" <misc2> {~}
<misc2_context>	::= "&" <misc1> {&addr} {! handle_lvcontext parent.1}
<misc2_context>	::= "++" <misc1> {++pre} {! handle_lvcontext parent.1}
<misc2_context>	::= "--" <misc1> {--pre} {! handle_lvcontext parent.1}
<misc2_lval>	::= "*" <misc2> {*deref}

;<misc1>			::= <base>

<misc1>			::= <misc1_context>
<misc1>			::= <base_num>
<misc1_context>	::= <base_id> <m_misc1>?
<misc1_context>	::= <base_expr> <m_misc1>?
<m_misc1>		::= "++" {! handle_lvcontext parent.parent.0} {++post}
<m_misc1>		::= "--" {! handle_lvcontext parent.parent.0} {--post}
;;;;;;;;;;;;;this is actually a problem -- the index of the {jumplabel} is dependent on whether or not there's an arglist
;<m_misc1>		::= "(" <arglist>? ")" {pushaddr 3} {jmp} {jumplabel 3} {pushv eax} {! handle_lvcontext parent.parent.0}
;<m_misc1>		::= "(" <arglist>? ")" {pushaddr 3} {jmp} {jumplabel 3} {pushv eax} {! handle_lvcontext parent.parent.0} {! swap_nodes parent.2, parent.parent.0}

<m_misc1>		::= "(" <arglist>? <fcall>
<fcall>			::= ")" {pushaddr 3} {nop} {jmp} {jumplabel 3} {! clean_args parent.parent.parent.0.0} {pushv eax} {! handle_lvcontext parent.parent.parent.0} {! swap_nodes parent.2, parent.parent.parent.0}
<arglist>		::= <assign> <margs>* {! reverse_args}
<margs>			::= "," <assign>

<base>			::= <base_id>
<base>			::= <base_num>
<base>			::= <base_expr>

;<base_id>		::= id {! check_decl_parent parent.0, parent.parent} {push %s}
<base_id>		::= id {! check_decl_parent parent.0, parent.parent} {! make_push parent}
;<base_num>		::= num {push %s}
<base_num>		::= num {! make_push parent}
<base_expr>		::= "(" <comma> ")"

