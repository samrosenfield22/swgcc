;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; grammar for the c programming language, sort of							   ;;;;;
;;;;; by default, the token on the lhs of the first production is the start symbol ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; top-level productions

<stmtlist>		::= <stmt>
<stmtlist>		::= <block>
<block>			::= "{" <stmt>* "}"

<stmt>			::= <mstmt>
<stmt>			::= <if>
<stmt>			::= <while>
<stmt>			::= <dowhile>
<stmt>			::= <forloop>
<stmt>			::= "return" <comma> ";" {pop eax} {pushaddr 0} {jmp}

<mstmt>			::= <comma> ";" {pop}
<mstmt>			::= <decl>

;maybe lol
<decl>			::= type <base_id> <declspec>?
<declspec>		::= <decl_assign> <mdecl_assign>* ";" {pop}
<declspec>		::= <mdecl_assign>* ";" {pop}
<declspec>		::= <funcdef>
<declspec>		::= ";" {pop}
<mdecl_assign>	::= "," {pop} <base_id> <decl_assign>?

<decl_assign>	::= <var_assign>
<decl_assign>	::= <array_assign>

<var_assign>	::= "=" <assign> {=}

<array_assign>	::= "[" <array_def>
<array_def>		::= <base_num> "]" <array_init>?
<array_def>		::= "]" <array_init>
<array_init>	::= "=" "{" <array_vals> "}"
<array_vals>	::= <base> <array_more>*
<array_more>	::= "," <base>



<comma>       	::= <assign> <mcomma>*
<mcomma>      	::= "," {pop} <assign> {,}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; conditionals

<if>			::= "if" "(" <comma> ")" {pushaddr 1} {jz} <stmtlist> {jumplabel 1}

;the comma and stmtlist branches get swapped
<while>			::= "while" "(" {pushaddr 1} {jmp} {jumplabel 2} <comma> ")" {jumplabel 1} <stmtlist> {pushaddr 2} {jnz}

<dowhile>		::= "do" {jumplabel 1} <stmtlist> "while" "(" <comma> ")" {pushaddr 1} {jnz}

;the condition (first comma) and stmtlist get swapped
<forloop>		::= "for" "(" <mstmt>? {pushaddr 1} {jmp} {jumplabel 2} ";" <comma>? ";" <comma>? {jumplabel 1} ")" <stmtlist> {pushaddr 2} {jnz}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; functions

;if the function contains a return statement, this stores the return value in eax, then jumps to jumplabel 0,
;skipping the {push 0} {pop eax}
;if execution reaches the end of the block (without hitting a return statement), then we set eax=0
<funcdef>		::= "(" <funcdeflist> ")" {enter} <block> {push 0} {pop eax} {jumplabel 0} {leave} {ret}
<funcdeflist>	::= "void"
<funcdeflist>	::= <funcdefarg> <mfuncdefarg>*
<funcdefarg>	::= type id?
<mfuncdefarg>	::= "," <funcdefarg>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; expressions (arithmetic, logical, bitwise, assignment)

<assign>		::= <logical> <massign>?
<massign> 		::= "=" <assign> {=}
<massign> 		::= "+=" <assign> {+=}
<massign> 		::= "-=" <assign> {-=}
<massign> 		::= "*=" <assign> {*=}
<massign> 		::= "/=" <assign> {/=}
<massign> 		::= "%=" <assign> {%=}
<massign> 		::= "<<=" <assign> {<<=}
<massign> 		::= ">>=" <assign> {>>=}
<massign> 		::= "&=" <assign> {&=}
<massign> 		::= "|=" <assign> {|=}
<massign> 		::= "^=" <assign> {^=}


<logical>		::= <bitwise> <mlogical>*
<mlogical>    	::= "&&" <bitwise> {&&}
<mlogical>    	::= "||" <bitwise> {||}

<bitwise>     	::= <equality> <mbitwise>*
<mbitwise>    	::= "&" <equality> {&}
<mbitwise>    	::= "|" <equality> {|}
<mbitwise>    	::= "^" <equality> {^}

<equality>    	::= <relational> <mequality>*
<mequality>   	::= "==" <equality> {==}
<mequality>   	::= "!=" <equality> {!=}

<relational>  	::= <shift> <mrelational>*
<mrelational> 	::= ">" <shift> {>}
<mrelational> 	::= ">=" <shift> {>=}
<mrelational> 	::= "<" <shift> {<}
<mrelational> 	::= "<=" <shift> {<=}

<shift>       	::= <sum> <mshift>*
<mshift>      	::= "<<" <sum> {<<}
<mshift>      	::= ">>" <sum> {>>}

<sum>			::= <prod> <msum>*
<msum>			::= "+" <prod> {+}
<msum>			::= "-" <prod> {-}

<prod>        	::= <misc2> <mprod>*
<mprod>       	::= "*" <misc2> {*}
<mprod>       	::= "/" <misc2> {/}
<mprod>       	::= "%" <misc2> {%}

<misc2>			::= <misc1>
<misc2>			::= <misc2_lval>
<misc2>			::= <misc2_context>
<misc2>			::= "!" <misc2> {!}
<misc2>			::= "~" <misc2> {~}
<misc2_context>	::= "&" <misc1> {&addr}
<misc2_context>	::= "++" <misc1> {++pre}
<misc2_context>	::= "--" <misc1> {--pre}
<misc2_lval>	::= "*" <misc2> {*deref}

;<misc1>			::= <base>

<misc1>			::= <misc1_context>
<misc1>			::= <base_num>
<misc1_context>	::= <base_id> <m_misc1>?
<misc1_context>	::= <base_expr> <m_misc1>?
<m_misc1>		::= "++" {++post}
<m_misc1>		::= "--" {--post}
<m_misc1>		::= "(" <arglist>? ")" {call} {pushv eax}
<arglist>		::= <comma> <margs>*
<margs>			::= "," <comma>

<base>			::= <base_id>
<base>			::= <base_num>
<base>			::= <base_expr>

;<base>			::= <base_num>
;<base>			::= <base_expr>

;<base_expr>	::= <base_other>
;<base_num>		::= <base_other>

<base_id>		::= id {push %s}
<base_num>		::= num {push %s}
<base_expr>		::= "(" <comma> ")"

;<base_other>	::= num {push %s}
;<base_other>	::= "(" <comma> ")"
